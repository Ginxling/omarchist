use super::ConfigGenerator;
use serde_json::{json, Value};

pub struct NeovimGenerator;

unsafe impl Send for NeovimGenerator {}
unsafe impl Sync for NeovimGenerator {}

impl ConfigGenerator for NeovimGenerator {
    fn get_app_name(&self) -> &'static str {
        "neovim"
    }

    fn get_file_name(&self) -> &'static str {
        "neovim.lua"
    }

    fn generate_config(&self, theme_data: &Value) -> Result<String, String> {
        let empty_obj = json!({});
        let neovim = theme_data.get("neovim").unwrap_or(&empty_obj);

        // Check if raw_config is provided
        if let Some(raw_config) = neovim.get("raw_config").and_then(|rc| rc.as_str()) {
            if !raw_config.trim().is_empty() {
                return Ok(format!(
                    "-- ────────────────────────────────────────────────────────────\n-- Omarchy Custom Theme for Neovim\n-- Generated by Omarchist\n-- ────────────────────────────────────────────────────────────\n\n{raw_config}"
                ));
            }
        }

        // Fallback to default template if no raw config provided
        Ok(r#"return {
  { "tahayvr/matteblack.nvim", lazy = false, priority = 1000 },
  {
		"LazyVim/LazyVim",
		opts = {
			colorscheme = "matteblack",
		},
	},
}"#
        .to_string())
    }

    fn get_config_schema(&self) -> Value {
        json!({
            "type": "object",
            "properties": {
                "raw_config": {
                    "type": "string",
                    "title": "Neovim Configuration",
                    "description": "Raw Lua configuration for Neovim theme",
                    "x-component": "textarea"
                }
            }
        })
    }

    fn parse_existing_config(&self, content: &str) -> Result<Value, String> {
        // Extract the raw config by removing the header comment if present
        let lines: Vec<&str> = content.lines().collect();
        let mut start_index = 0;

        // Skip header comments
        for (i, line) in lines.iter().enumerate() {
            if line.starts_with("--") {
                continue;
            }
            if line.trim().is_empty() {
                continue;
            }
            start_index = i;
            break;
        }

        let raw_config = lines[start_index..].join("\n");
        Ok(json!({
            "raw_config": raw_config
        }))
    }
}
